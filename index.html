<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>index</title><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 20pt; }
 .p, p { color: #505050; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; margin:0pt; }
 .s1 { color: #909090; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 12pt; }
 h2 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 16pt; }
 .s2 { color: #00F; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s4 { color: #00F; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 h3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 .s6 { color: #505050; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 h4 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s8 { color: #00F; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .a, a { color: #505050; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li:before {content: "• "; color: #505050; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li:before {counter-increment: d1; content: counter(d1, decimal)". "; color: #505050; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l2> li:first-child:before {counter-increment: d1 0;  }
 #l3 {padding-left: 0pt; }
 #l3> li:before {content: "• "; color: #505050; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
</style></head><body><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span><img width="97" height="36" alt="IBM®" title="IBM®" src="index/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="700" height="2" alt="image" src="index/Image_002.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 318pt;text-indent: 0pt;text-align: left;"><span><img width="287" height="36" alt="IBM®" title="IBM®" src="index/Image_003.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-top: 13pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark0">Understanding architectural assets</a></h1><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Peter Eeles September 15, 2007</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 11pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">from The Rational Edge: This article discusses the various kinds of reusable assets available to the software architect, explains their characteristics and interrelationships, and offers tips on how best to make use of them.</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="212" height="141" alt="illustration" title="illustration" src="index/Image_004.jpg"/></span></p><p class="s1" style="padding-top: 4pt;padding-left: 165pt;text-indent: 0pt;text-align: left;">The life of a software architect is a long and rapid succession of</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">suboptimal design decisions taken partly in the dark. <span class="p">-- Philippe Kruchten</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark1">Introduction</a></h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">The purpose of this article is to shed some light on the darkness Kruchten<span style=" color: #00F;">1 </span>refers to, by discussing a key characteristic of successful software architectures -- the use of reusable assets. From fine- grained programming idioms to large-grained, off-the-shelf packaged solutions, reusable assets provide a valuable vehicle for capitalizing on the work of other successful architects.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="http://www.ibm.com/developerworks/rational/library/jul07/ferreira/index.html" style=" color: #909090; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank">With the recent release of IBM® Rational® Asset Manager (</a>See recent article <span style=" color: #909090;">) Rational customers now have a better way to locate existing software assets, in order to reduce duplication of effort, reduce costs, improve software quality, and shorten time to market. But considerations around how to approach asset reuse from the perspective of the software architect can still present challenges. There are many different types of assets to consider, although the terms used to refer to them are not always consistent, and it is not always clear what value they provide. For example: What is the difference between an architectural style and a reference architecture? How does a mechanism differ from a framework?</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">In this article, I discuss the different types of reusable assets available to the architect, their characteristics and interrelationships, and how best to make use of them.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="http://www.ibm.com/developerworks/ibm/trademarks/" class="s4" target="_blank">© Copyright IBM Corporation 2007 Trademarks</a></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">developerWorks® ibm.com/developerWorks/</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark2">The case for reusable assets</a></h2><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Inspiration for deriving an architecture comes from many places, and will vary depending on many factors, including the novelty of the system, the development process or method being followed, and the skills of the architect. Kruchten suggests that there are three main sources of architecture: <span class="s1">theft, method</span>, and <span class="s1">intuition</span>, as illustrated in Figure 1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Figure 1: Sources of architecture</h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 16pt;text-indent: 0pt;text-align: left;"><span><img width="342" height="142" alt="Figure 1: Sources of architecture" title="Figure 1: Sources of architecture" src="index/Image_005.jpg"/></span></p><p class="s1" style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Theft <span class="p">refers to the reuse of existing assets. Most elements of a software architecture are derived from a previous system of the same kind, another system with overall similar characteristics,</span></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">or an architecture found in technical literature. <span class="s1">Method </span>refers to a systematic way by which an architecture is derived from the system&#39;s requirements. Finally, <span class="s1">intuition </span>reflects the experience of the software architect, who recognizes some pattern or finds other inspiration for an architectural element.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">The relative width of the arrows shown in Figure 1 indicates the relative emphasis of these three sources, depending on the novelty of the system. A classical system may comprise 80% theft, 19% method, and 1% intuition, and an unprecedented system may comprise 30% theft, 50% method, and 20% intuition. In either case, the reuse of existing assets is significant. Put another way, a good architect does not reinvent the wheel.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark3">Characterizing architectural assets</a></h2><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Clearly, considering reusable assets can significantly help architects in their work since this reduces the number of assets that must be created from scratch. Not surprisingly, successful architects tend to be conscious of the assets available. The reuse of assets within the project can have a significant bearing on the project schedule, cost, and quality of the delivered system.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">In a general sense, reusable assets can be applied in all of the software engineering disciplines. For example, a reusable asset could represent a reusable requirement (a requirement that occurs over and over, within different systems), a reusable solution element (such as an architectural pattern or reusable code), a reusable test, and so on. In this article, I focus on those reusable assets that are of most relevance to the software architect (see Figure 2). Each type of reusable asset can be characterized across two dimensions: its granularity, and its level of implementation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Bear in mind that the assets discussed here are based on my experiences in working with a number of clients. As there is no agreed-upon industry definition for the terms used to refer to</p><p class="s6" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">ibm.com/developerWorks/ developerWorks®</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">a number of these assets, I use these terms based on their meanings in the context of these experiences.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Figure 2: Asset granularity and level of implementation</h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span><img width="451" height="295" alt="Figure 2: Asset granularity and level of implementation" title="Figure 2: Asset granularity and level of implementation" src="index/Image_006.jpg"/></span></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">As shown in Figure 2, assets can be broadly categorized in terms of their level of implementation:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l1"><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><h4 style="display: inline;">No Implementation. <span class="p">Such assets have no implementation, and are represented in an abstract form such as a model or document. Such assets include various types of patterns, architectural styles, and reference architectures.</span></h4></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: justify;"><h4 style="display: inline;">Partial Implementation. <span class="p">Such assets are considered partial implementations, but require additional elements before they can be instantiated. Such assets include frameworks and packaged applications.</span></h4></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><h4 style="display: inline;">Complete Implementation. <span class="p">Such assets are considered to be complete implementations, and can be instantiated as-is, without modification. Such assets include components, component libraries, and legacy systems.</span></h4><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">The different types of assets are not independent. For example, the selection of large-grained assets typically represents a major architectural decision on the project, which then constrains and guides the selection of finer-grained assets and so on. This interdependency within the selection of asset types is reflected in Figure 3.</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">developerWorks® ibm.com/developerWorks/</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Figure 3: Large-grained assets constrain the choice of fine-grained assets</h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span><img width="452" height="213" alt="Figure 3: Large-grained assets constrain the choice of fine-grained assets" title="Figure 3: Large-grained assets constrain the choice of fine-grained assets" src="index/Image_007.jpg"/></span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">This is, of course, a gross generalization. But it does give some indication of the architectural significance of each of the reusable assets considered in this article.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark4">An architectural asset metamodel</a></h2><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">The interrelationships among the various types of assets alluded to above are shown in more detail in Figure 4, which is a UML class diagram defining a metamodel of architectural assets.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Figure 4: Architectural asset metamodel</h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span><img width="457" height="226" alt="Figure 4: Architectural asset metamodel" title="Figure 4: Architectural asset metamodel" src="index/Image_008.jpg"/></span></p><p style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Following are brief descriptions of each of the assets defined in this metamodel and how they relate:</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p class="s1" style="display: inline;">Architectural Patterns, Design Patterns and Programming Patterns <span class="p">are all types of Patterns.</span></p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">An <span class="s1">Architectural Style </span>is a type of Architectural Pattern.</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">A <span class="s1">Pattern </span>is used by any number of Reference Architectures, Application Frameworks and Legacy Applications.</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">A <span class="s1">Reference Architecture </span>makes use of any number of Patterns and Frameworks, and is used by any number of Legacy Applications.</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">An <span class="s1">Application Framework </span>makes use of any number of patterns, may make use of a Reference Architecture, and is used by any number of Legacy Applications.</p><p class="s6" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">ibm.com/developerWorks/ developerWorks®</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li style="padding-top: 4pt;padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">A <span class="s1">Packaged Application </span>is a type of Application Framework.</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">An <span class="s1">Architectural Mechanism </span>is a type of Application Framework.</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">A <span class="s1">Legacy Application </span>makes use of any number of Patterns, Application Frameworks, Component Libraries, and may make use of a Reference Architecture.</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">A <span class="s1">Component Library </span>is used by any number of Application Frameworks and Legacy Applications, and contains any number of Components.</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">A <span class="s1">Component </span>is contained within a Component Library.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark5">Patterns</a></h3><p style="padding-top: 11pt;padding-left: 6pt;text-indent: 0pt;line-height: 134%;text-align: left;">The term pattern is used to represent many different types of reusable elements, and so patterns represent probably the most general type of asset. According to the UML user guide<span style=" color: #00F;">2</span>:</p><p class="s1" style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">[A pattern is] a common solution to a common problem in a given context.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Since a pattern is such a general concept, it can be applied throughout the development lifecycle. Patterns come in many forms, including requirements patterns, architectural patterns, design patterns, programming patterns (referred to as idioms), testing patterns, project management patterns, process patterns, organizational patterns, and so on.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Given the importance of patterns to the architect, it is not surprising that the literature places significant emphasis on identifying patterns, and on techniques for documenting patterns. Applying lessons learned from civil engineering, the &quot;patterns movement&quot; has really gained momentum over the last ten years. There are many publications and websites dedicated to various types of</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 134%;text-align: left;">patterns, including platform-independent design patterns<span style=" color: #00F;">3</span>, architectural patterns <span style=" color: #00F;">4</span>, and design patterns <span style=" color: #00F;">5</span>. The inspiration for these publications stems from the influential works of the building architect Christopher Alexander<span style=" color: #00F;">6 </span>. There are even sources of antipatterns; for example:</p><p class="s1" style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 134%;text-align: left;">[An antipattern is] a commonly occurring pattern or solution that generates decidedly negative consequences. An antipattern may be a pattern in the wrong context <span style=" color: #00F;">7</span>.</p><p style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">However, architects are particularly interested in those patterns that directly influence their work. These patterns are generally:</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><h4 style="display: inline;">Architectural patterns. <span class="p">These are large-grained patterns, an example of which is the Layers pattern as defined by Buschmann. This pattern structures applications into groups, where each group represents a particular level of abstraction. One of the most familiar examples of layering is the OSI 7-layer model, defined by the International Organization for Standardization (ISO), where each layer builds upon the capabilities found in &quot;lower&quot; layers.</span></h4></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><h4 style="display: inline;">Design patterns. <span class="p">These are finer-grained patterns, an example of which is the Observer pattern as defined by Gamma. This pattern, also known as Publish-Subscribe, allows an object to subscribe to events that occur in a target object, and to be notified when such events occur.</span></h4></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><h4 style="display: inline;">Programming patterns (idioms) <span class="p">Idioms are reusable programming expressions, defined in a particular programming language.</span></h4><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">developerWorks® ibm.com/developerWorks/</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Patterns are not only of interest to the architect in terms of reusing existing experience, but also are a valuable mechanism for defining elements of the solution that should be applied consistently. They represent an opportunity for the architect to share his or her knowledge with the project in a &quot;codified&quot; form. Although there are many templates for describing a pattern (or antipattern), there is much commonality between them. Most pattern descriptions include:</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">The name of the pattern</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">The context within which the pattern is used</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">The specific problem(s) that the pattern solves</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">The solution the pattern provides</p></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><p style="display: inline;">Related patterns</p><p style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">You can also represent the pattern solution visually, in terms of both structure and behavior. Figure 5 is a UML class diagram showing the participants in the Observer pattern. One of the primary goals of this pattern is to remove the need for the subject to have any knowledge of the elements observing it. In this case, this is achieved by introducing a superclass (Subject) that maintains a list of observers.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Figure 5: Structural elements in the Observer pattern</h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span><img width="320" height="201" alt="Figure 5: Structural elements in the Observer pattern" title="Figure 5: Structural elements in the Observer pattern" src="index/Image_009.jpg"/></span></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">In addition to showing the structure of a pattern, you can also show its behavior. Figure 6 is a UML sequence diagram showing how the structural elements within the Observer pattern collaborate.</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">This diagram shows the behavior when the subject is updated. This results in a notification message being sent to each observer, informing them that the subject has changed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Figure 6: Behavior in the Observer pattern</h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span><img width="411" height="161" alt="Figure 6: Behavior in the Observer pattern" title="Figure 6: Behavior in the Observer pattern" src="index/Image_010.jpg"/></span></p><p class="s6" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">ibm.com/developerWorks/ developerWorks®</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">The point here is not to demonstrate the Observer pattern, but rather to show how architectural experience can be captured and communicated. Architects typically reuse patterns identified from external sources, and also define their own patterns to be used on the project, in order to ensure some level of architectural consistency. It is also, of course, more efficient to capture a pattern once, and note where it has been applied, rather than to describe every use of the pattern in detail.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Describing a pattern in a UML modeling tool also opens up opportunities to apply the pattern to a UML model. In this case, the roles defined within the pattern are played by elements in the model. The pattern is then applied, and the model is updated according to the pattern. For example, new relationships might be created, or new operations added that conform to the pattern definition. This capability can complement a model-driven development approach to software development.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Patterns in the broadest sense can also be applied to a particular class of problem -- when transforming an input to an output. For example, you might want to generate code from a UML model. The rules that govern the transformation could be specified as a pattern. Similarly, you can use the same philosophy when transforming from one model to another model. The concept of model transformation is one of the cornerstones of the Model Driven Architecture (MDA) initiative from the Object Management Group (OMG).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">If such automation is made available, then it can be argued that the pattern has a partial implementation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark6">Architectural styles</a></h3><p style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">An architectural style is a type of architectural pattern that can help kick-start the process of moving from requirements to solution.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">[An architectural style] defines a family of systems in terms of a pattern of structural organization. More specifically, an architectural style defines a vocabulary of components and connector types,</p><p class="s1" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">and a set of constraints on how they can be combined<span style=" color: #00F;">8</span>.</p><p style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">An architectural style applies at the system level, and therefore has a major impact on the architecture. Also, a given system may exhibit more than one architectural style. Some examples</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">of architectural styles are shown below<span style=" color: #00F;">9</span>.</p></li><li style="padding-top: 12pt;padding-left: 31pt;text-indent: -10pt;text-align: left;"><h4 style="display: inline;">Client-server. <span class="p">This is a widely-used style that supports the physical separation of client-side processing (such as a browser) and server-side processing (such as an application server that accesses a database).</span></h4></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><h4 style="display: inline;">Event-based. <span class="p">This style is similar to the Observer pattern in that it promotes a publish- subscribe way of working. However, rather than this being confined to specific instances within the architecture, it is applied strategically across large areas of the architecture.</span></h4></li><li style="padding-left: 31pt;text-indent: -10pt;text-align: left;"><h4 style="display: inline;">Pipes-and-filters. <span class="p">This style comprises a series of filters, which provide data transformation, and pipes that connect the filters. Examples of a pipes-and-filters style include compilers, signal processing, and even elements of a Straight Through Processing (STP) solution used in financial markets, where the trade process for capital markets and payments transactions is</span></h4></li></ul><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">developerWorks® ibm.com/developerWorks/</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">conducted electronically. This concept is also used in the energy sector for electricity, oil, and gas trading.</p><h3 style="padding-top: 10pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark7">Reference architectures</a></h3><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">A reference architecture exhibits the same characteristics as any other architecture, with some important differences. The first difference is that it does not normally have a physical manifestation (as indicated in Figure 2), and is simply documentation; in the form of models, for example. The second is that it is often incomplete, in the sense that it contains &quot;gaps&quot; that must be plugged before it can be considered to represent a complete definition of the architecture of the system under consideration.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Reference architectures come in many different forms, reflecting the many different interpretations of architecture. They may, for example, be technology-independent or technology-specific.</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Examples of reference architectures include a financial services reference architecture, the Java 2 Enterprise Edition (J2EE) architecture, and the .NET architecture.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark8">Application frameworks</a></h2><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">An application framework (sometimes referred to as simply a <span class="s1">framework</span>) represents the partial implementation of a specific area of an application. Probably the most widely-known frameworks are those supporting user interfaces, such as Java Server Faces, and Microsoft ASP.NET. However, this thinking can also be extended to entire platforms, such as a J2EE implementation, or .NET. Such platforms can therefore be characterized as either a reference architecture or as an application framework.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark9">Architectural mechanisms</a></h3><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">As architects, we frequently characterize solution elements as <span class="s1">mechanisms</span>, such as &quot;the mechanism for achieving X&quot; or &quot;this element is underpinned by mechanism Y.&quot; Examples of mechanisms include a persistency mechanism, an error logging mechanism, a communication mechanism, and a shopping cart. The distinction between a mechanism and a pattern is that a mechanism is more concrete and may have a partial implementation. A mechanism may also adopt several patterns. According to the IBM Rational Unified Process® (RUP®):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Architectural mechanisms represent common concrete solutions to frequently encountered problems. They may be patterns of structure, patterns of behavior, or both.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark10">Packaged applications</a></h2><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">A packaged application is a large-grained Commercial-Off-The-Shelf (COTS) product that provides a significant amount of functional capability as well as reuse potential, such as a Customer Relationship Management (CRM) application, or an Enterprise Resource Planning (ERP) application.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">The amount of custom development required is greatly reduced by using a packaged application, and the primary focus is on configuring the application. One of the areas focused upon is a fit/</p><p class="s6" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">ibm.com/developerWorks/ developerWorks®</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">gap analysis of how close the packaged application comes to satisfying the project requirements. However, it is also frequently the case that, when adopting a packaged application, it becomes necessary to accommodate any constraints the application imposes. In this sense, the use of a packaged application can have a &quot;bottom-up&quot; influence on the architecture.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark11">Components and component libraries</a></h3><p style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">The most widely understood form of reuse is with respect to implementation elements, such as individual components, and component libraries (or class libraries, or procedure libraries). An example of a component, in this context, might be a GUI widget, such as a table, provided in a particular technology. An example of a component library might be the Java class library, or the ADO.NET library for data access.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">In this article, I define a component in the most general sense -- as simply an implementation element. A service in a service-oriented architecture (SOA) could, therefore, also be considered a component.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark12">Legacy applications</a></h3><p style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">The largest, concrete, reusable asset that the architect might consider is an existing system. The use of such systems normally results in the need to integrate with the system, which is sometimes referred to as <span class="s1">legacy integration </span>or <span class="s1">enterprise application integration </span>(EAI). As for packaged applications, the level of reuse can be high, and the effort is focused on integration rather than custom development.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">One of the key distinctions between packaged application development, enterprise application integration, and custom development, is the level of reuse of existing assets. When undertaking packaged application development or enterprise application integration, much of the architect&#39;s work is done, since you don&#39;t need to create large elements of the system. In addition, many of the significant decisions that an architect would make have already been made, and are manifest in the chosen applications being used.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">The selection of such significant assets may also have a bearing on the approach taken to developing the system under consideration. For example, the selection of a packaged application may result in different software development practices being applied than if you were integrating a legacy system or building custom code. Quite often, a hybrid approach is taken since many software development projects apply many different types of reusable asset concurrently.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark13">The Reusable Asset Specification</a></h2><p style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">The last few years has seen a renewed focus on reusable assets as a means of accelerating project performance. The widespread acceptance of SOAs, for example, has led to a focus on how the associated reusable assets (services, in this case) are developed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 134%;text-align: left;">Underpinning such initiatives is a need to describe reusable assets. This is where the Reusable Asset Specification <span style=" color: #00F;">10 </span>(RAS) comes in. This is an OMG standard that fundamentally defines two</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">developerWorks® ibm.com/developerWorks/</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">aspects of a reuse strategy. The first is a standard for describing a reusable asset. The second is a standard for an interface to a RAS-compliant repository, referred to as a RAS Repository Service.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark14">Other reuse considerations</a></h2><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Of course, there is more to achieving successful asset reuse than understanding the types of assets available. However, additional considerations lie outside the scope of this article. In</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">particular, this article has not touched on the process for creating or applying the various asset types mentioned. This would include the roles that might exist in an organization in support of a strategic reuse initiative, the tasks that are performed (especially around the creation, use, and maintenance of assets), and any specific artifacts that might be produced that specifically</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">support a reuse initiative (such as an asset catalog). Also, this article does not address the broader implications on an organization, such as the embedding of a reuse &quot;culture.&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark15">Summary</a></h2><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">There are many different flavors of reusable asset at the disposal of the software architect, and the use of such assets can dramatically improve project performance when applied correctly. This article has attempted to provide an overview of commonly encountered assets available to the architect in his or her work, and how various reusable assets relate to one another.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark16">Acknowledgements</a></h2><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">I would like to thank Peter Cripps, Carlos Ferreira, and Glenn Mitchell for their feedback on early drafts of this paper.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark17">Notes</a><a name="bookmark18">&zwnj;</a></h2><ol id="l2"><li style="padding-top: 9pt;padding-left: 31pt;text-indent: -12pt;text-align: left;"><p style="display: inline;">From <span class="s1">Mommy, Where Do Software Architectures Come From? </span>Philippe Kruchten, 1st International Workshop on Architectures for Software Systems, Seattle, WA, 1995.</p></li><li style="padding-left: 31pt;text-indent: -12pt;text-align: left;"><p class="s1" style="display: inline;">The Unified Modeling Language User Guide. <span class="p">Grady Booch, James Rumbaugh, and Ivar Jacobson, Addison Wesley, ISBN 0-201-57168-4, 1999.</span></p></li><li style="padding-left: 31pt;text-indent: -12pt;text-align: left;"><p class="s1" style="display: inline;">Analysis Patterns -- Reusable Object Models. <span class="p">Martin Fowler, Addison Wesley, ISBN 0-201-89542-0, 1997.</span></p></li><li style="padding-left: 31pt;text-indent: -12pt;text-align: left;"><p class="s1" style="display: inline;">Pattern-Oriented Software Architecture -- A System of Patterns<span class="p">, Frank Buschmann et al., John Wiley and Sons, ISBN 0-471-95869-7, 1996.</span></p></li><li style="padding-left: 31pt;text-indent: -12pt;text-align: left;"><p class="s1" style="display: inline;">Design Patterns -- Elements of Reusable Object-Oriented Software<span class="p">, Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, Addison Wesley, ISBN 0-201-63361-2, 1995.</span></p></li><li style="padding-left: 31pt;text-indent: -12pt;text-align: left;"><p style="display: inline;">Among Alexander&#39;s most influential works are:</p><ul id="l3"><li style="padding-left: 57pt;text-indent: -10pt;text-align: left;"><p class="s1" style="display: inline;">Notes on the Synthesis of Form <span class="p">by Christopher Alexander, Harvard University Press, 1964.</span></p></li><li style="padding-left: 57pt;text-indent: -10pt;text-align: left;"><p class="s1" style="display: inline;">A Pattern Language <span class="p">by Christopher Alexander, Sara Ishikawa, and Murray Silverstein. Oxford University Press, 1977.</span></p></li><li style="padding-left: 57pt;text-indent: -10pt;text-align: left;"><p class="s1" style="display: inline;">The Timeless Way of Building <span class="p">by Christopher Alexander. Oxford University Press, ISBN 0-19-502402-8, 1979.</span></p><p class="s6" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">ibm.com/developerWorks/ developerWorks®</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li style="padding-top: 4pt;padding-left: 31pt;text-indent: -12pt;text-align: justify;"><p class="s1" style="display: inline;">AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis. <span class="p">William Brown, Raphael Malveau, Hays McCormick, and Thomas Mowbray, John Wiley and Sons, ISBN 0-471-19713-0, 1998.</span></p></li><li style="padding-left: 31pt;text-indent: -12pt;text-align: left;"><p class="s1" style="display: inline;">Software Architecture: Perspectives on an Emerging Discipline<span class="p">. Mary Shaw and David Garlan, Prentice Hall, ISBN 0-13-182957-2, 1996.</span></p></li><li style="padding-left: 31pt;text-indent: -12pt;text-align: left;"><p style="display: inline;">These and other architectural styles are described in Shaw (above) and also in <span class="s1">Software Systems Architecture -- Working with Stakeholders using Viewpoints and Perspectives </span>by Nick Rozanski and Eoin Woods, Addison Wesley, ISBN 0-321-11229-6, 2005.</p></li><li style="padding-left: 31pt;text-indent: -19pt;text-align: left;"><p class="s1" style="display: inline;">Reusable Asset Specification, Object Management Group, Inc<span class="p">. Document number 04-06-06, June 2004.</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="http://www.ibm.com/legal/copytrade.shtml)" class="s8" target="_blank" name="bookmark19">© Copyright IBM Corporation 2007 </a><a href="http://www.ibm.com/developerworks/ibm/trademarks/" class="a" target="_blank">(www.ibm.com/legal/copytrade.shtml) </a><a href="http://www.ibm.com/developerworks/ibm/trademarks/)" class="s8" target="_blank">Trademarks </a><a href="http://www.ibm.com/developerworks/ibm/trademarks/)" target="_blank">(www.ibm.com/developerworks/ibm/trademarks/)</a></p></body></html>
